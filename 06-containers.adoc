= 容器 Containers



容器是一种数据类型，它包含一组元素并允许我们访问这些元素。通常容器也是可迭代的，这意味着我们可以像在<<循环 Loops, 循环 Loops>>中使用字符串那样使用它们。

例如，购物清单是我们想购买的物品的容器，而质数列表则是数字的容器。用伪代码表示：
[source]
----
groceryList = [ham, eggs, bread, apples]
primes = [1, 2, 3, 5, 7]
----



== 数组 Arrays

数组是最简单的容器类型。数组是同质的，即数组中的所有元素必须具有相同的类型。数组的大小也是固定的，意味着元素的数量（或者更准确地说：可能的元素数量）必须在编译时已知。这意味着我们称数组为“固定长度的同质容器”。

数组类型使用 `array[<length>, <type>]` 声明，其中 `length` 是数组的总容量（可容纳的元素数量）， `type` 是其所有元素的类型。如果长度和类型可以从传递的元素中推断出来，则可以省略声明。

数组的元素被包含在方括号内。
[source]
----
var
  a: array[3, int] = [5, 7, 9]
  b = [5, 7, 9]        <1>
  c = []  # error      <2>
  d: array[7, string]  <3>
----
<1> 如果我们提供了值，数组 `b` 的长度和类型在编译时就是已知的。虽然正确，但无需像数组 `a` 那样特别声明。
<2> 这种声明方式既无法推断元素的长度，也无法推断其类型——这会导致错误。
<3> 正确声明空数组（稍后将填充）的方法是给出其长度和类型，而不提供元素值——数组 `d` 可以包含七个字符串。


由于数组的长度必须在编译时已知，因此以下代码将无法工作：

[source]
----
const m = 3
let n = 5

var a: array[m, char]
var b: array[n, char] # error <1>
----
<1> 这会产生错误，因为 `n` 是用 `let` 声明的——它的值在编译时是未知的。我们只能使用用 `const` 声明的值作为数组初始化的 `length` 参数。





== 序列 Sequences

序列（Sequences）是一种类似于数组的容器，但其长度无需在编译时已知，且可在运行时动态变化：我们仅需通过 `seq[<type>]` 声明所包含元素的类型。序列也是同质的（homogeneous），即序列中的每个元素必须具有相同的类型。

序列的元素被包含在 `@[` 和 `]` 之间。

[source]
----
var
  e1: seq[int] = @[]   <1>
  f = @["abc", "def"]  <2>
----
<1> 空序列的类型必须被声明。
<2> 非空序列的类型可以被推断出来。在这个例子中，它是一个包含字符串的序列。

另一种初始化空序列的方法是调用 `newSeq` 过程。我们将在<<过程 Procedures, 下一章节>>更详细地介绍过程调用，但现在只需知道这也是一种可行方式：

[source]
----
var
  e = newSeq[int]() <1>
----
<1> 在方括号内提供类型参数可以让过程知道它应该返回某种特定类型的序列。 +
一个常见的错误是遗漏了在末尾的 `()` ，这是必需的。


我们可以使用 `add` 函数向序列中添加新元素，这与处理字符串的方式类似。为此，序列必须是可变的（用 `var` 定义），并且我们添加的元素必须与序列中的元素类型相同。

[source]
.seq.nim
----
include::{source-dir}/seq.nim[]
----
<1> 添加一个相同类型（char）的新元素。
<2> 添加另一个包含相同类型的序列。

[source, output]
----
@['x', 'y', 'z']
@['1', '2', '3', 'x', 'y', 'z']
----

尝试将不同类型传递给现有序列会产生错误：

[source]
----
var i = @[9, 8, 7]

i.add(9.81) # error <1>
g.add(i)    # error <2>
----
<1> 尝试将 `float` 添加到 `int` 的序列中。
<2> 尝试将序列 `int` 添加到序列 `char` 中


由于序列长度可变，我们需要一种获取其长度的方法，为此可以使用 `len` 函数。

[source]
----
var i = @[9, 8, 7]
echo i.len

i.add(6)
echo i.len
----

[source, output]
----
3
4
----





== 索引 Indexing 与 切片 slicing

索引允许我们通过下标从容器中获取特定元素。
可以将索引视为容器内部的位置标识。

Nim与许多编程语言一样采用零基索引，即容器中第一个元素的索引为零，第二个元素的索引为一，以此类推。

若要从后向前索引，需使用 `^` 前缀。最后一个元素（即倒数第一个）的索引是 `^1` 。

索引的语法是 `<container>[<index>]` 。

[source]
.indexing.nim
----
include::{source-dir}/indexing.nim[lines=1..4]
----
<1> 零基索引：索引 `1` 对应的元素是 `b` 。
<2> 获取最后一个元素。

[source, output]
----
b
e
----

{nbsp}

切片操作允许我们通过一次调用获取一系列元素。它使用的语法与范围（在 <<for循环(For loop), for循环(For loop)>> 中介绍过）相同。


If we use `start .. stop` syntax, both ends are included in the slice.
Using `start ..< stop` syntax, the `stop` index is not included in the slice.

The syntax for slicing is `<container>[<start> .. <stop>]`.

[source]
.indexing.nim
----
include::{source-dir}/indexing.nim[lines=6..8]
----

[source, output]
----
@[a, b, c, d]
@[a, b, c]
----


Both indexing and slicing can be used to assign new values to the existing mutable containers and strings.

[source]
.assign.nim
----
include::{source-dir}/assign.nim[]
----
<1> Array of length 5 has indexes from zero to four. We will assign a value to each element of the array.
<2> Assigning (changing) the second element (index 1) of a sequence.
<3> Changing characters of a string at indexes 8 and 9.


[source, output]
----
[0, 7, 14, 21, 28]
@['p', 'q', 'r']
Tom and Barry
----




== Tuples

Both of the containers we've seen so far have been homogeneous.
Tuples, on the other hand, contain heterogeneous data, i.e. elements of a tuple can be of different types.
Similarly to arrays, tuples have fixed-size.

The elements of a tuple are enclosed inside of parentheses.

[source]
.tuples.nim
----
include::{source-dir}/tuples.nim[lines=1..3]
----
<1> Tuples can contain fields of different types. In this case: `string`, `int`, and `char`.

[source, output]
----
(Field0: "Banana", Field1: 2, Field2: 'c')
----



We can also name each field in a tuple to distinguish them.
This can be used for accessing the elements of the tuple, instead of indexing.

[source]
.tuples.nim
----
include::{source-dir}/tuples.nim[lines=5..10]
----
<1> Changing the value of a field by using the field's index.
<2> Changing the value of a field by using the field's name.

[source, output]
----
(name: "Apple", weight: 7, rating: 'c')
----





== Exercises

1. Create an empty array which can contain ten integers.
    * Fill that array with numbers 10, 20, ..., 100. (Hint: use loops)
    * Print only the elements of that array that are on odd indices (values 20, 40, ...).
    * Multiply elements on even indices by 5. Print the modified array.

2. Re-do the <<_exercises_2, Collatz conjecture exercise>>, but this time instead of printing each step, add it to a sequence.
    * Pick a starting number. Interesting choices, among others, are 9, 19, 25 and 27.
    * Create a sequence whose only member is that starting number
    * Using the same logic as before, keep adding elements to the sequence until you reach 1
    * Print the length of the sequence, and the sequence itself

3. Find the number in a range from 2 to 100 which will produce the longest Collatz sequence.
    * For each number in the given range calculate its Collatz sequence
    * If the length of current sequence is longer than the previous record, save the current length and the starting number as a new record (you can use the tuple `(longestLength, startingNumber)` or two separate variables)
    * Print the starting number which gives the longest sequence, and its length
