= 过程 Procedures



过程（在其他编程语言中常称为函数）是将执行特定任务的代码封装为一个独立单元。
这种代码组织方式的优势在于，我们可以直接调用这些过程，而无需在每次需要时重复编写相同的代码。

在前面的某些章节中，我们探讨了不同场景下的考拉兹猜想。通过将考拉兹猜想逻辑封装成过程，我们就能在所有练习中调用相同的代码。

到目前为止，我们已经使用了许多内置过程，例如用于打印的 `echo` 、向序列添加元素的 `add` 、增加整数值的 `inc` 、获取容器长度的 `len` 等。现在我们将学习如何创建和使用自己的过程。

使用过程（procedure）的一些优势包括：

* 减少代码重复
* 通过为代码片段赋予功能描述性名称，使代码更易阅读
* 将复杂任务分解为更简单的步骤

正如本节开头所述，在其他语言中过程(procedure)常被称为函数(function)。若从数学函数的定义来看，这其实是个不太准确的称谓。数学函数接收一组参数（如 `f(x, y)` ，其中 `f` 是函数， `x` 和 `y` 是其参数），对于相同的输入总是返回相同的结果。

另一方面，程序化过程对于给定输入并不总是返回相同输出。有时它们根本不返回任何内容。这是因为我们的计算机程序可以在之前提到的变量中存储状态，这些过程可以读取和更改状态。在Nim中，当前保留使用 `func` 这个词来表示数学上更准确的函数类型，强制要求无副作用。




== 声明过程 Declaring a procedure

在使用（调用）过程之前，我们需要创建它并定义其功能。

过程通过使用 proc 关键字和过程名称来声明，后跟括号内的输入参数及其类型，最后部分是一个冒号和过程返回值的类型，如下所示：

[source]
----
proc <name>(<p1>: <type1>, <p2>: <type2>, ...): <returnType>
----

过程体以缩进块的形式编写，紧跟在带有 `=` 符号的声明之后。

[source]
.callProcs.nim
----
include::{source-dir}/callProcs.nim[lines=1..8]
----
<1> 声明名为 `findMax` 的过程，它有两个参数 `x` 和 `y` ，并返回一个 `int` 类型。
<2> 要从过程中返回值，我们使用 `return` 关键字。


{nbsp}

[source]
----
proc echoLanguageRating(language: string) = <1>
  case language
  of "Nim", "nim", "NIM":
    echo language, " is the best language!"
  else:
    echo language, " might be a second-best language."
----
<1> `echoLanguageRating` 过程只是回显给定的名称，它不返回任何内容，因此没有声明返回类型。


{nbsp}

通常情况下，我们不允许修改传入的任何参数。类似这样的操作会引发错误：

[source]
----
proc changeArgument(argument: int) =
  argument += 5

var ourVariable = 10
changeArgument(ourVariable)
----

为了让这能够正常工作，我们需要允许Nim以及使用我们过程的程序员通过将参数声明为变量来修改它：

[source]
----
proc changeArgument(argument: var int) = <1>
  argument += 5

var ourVariable = 10
changeArgument(ourVariable)
echo ourVariable
changeArgument(ourVariable)
echo ourVariable
----
<1> 注意 `argument` 现在被声明为 `var int` ，而不仅仅是 `int` 。

[source, output]
----
15
20
----

这当然意味着我们传入的名称也必须声明为变量，传入用 `const` 或 `let` 赋值的内容会引发错误。

虽然将内容作为参数传递是良好的实践，但也可以使用过程外部声明的名称，包括变量和常量：

[source]
----
var x = 100

proc echoX() =
  echo x  <1>
  x += 1  <2>

echoX()
echoX()
----
<1> 这里我们访问外部变量 `x` 。
<2> 我们可以更新它的值，因为它被声明为变量。
[source, output]
----
100
101
----


== 调用程序 Calling the procedures

声明过程后，我们可以调用它。在许多编程语言中，调用过程/函数的常规方式是声明其名称并在括号内提供参数，如下所示：

[source]
----
<procName>(<arg1>, <arg2>, ...)
----

调用过程的结果可以存储在变量中。

如果要从上面的示例中调用我们的 findMax 过程，并将返回值保存在变量中，我们可以这样做：

[source]
.callProcs.nim
----
include::{source-dir}/callProcs.nim[lines=10..18]
----
<1> The result from the function `findMax` is here named `c`, and is called with the results of our first two calls (`findMax(987, 321)`).

[source, output]
----
987
321
987
----

{nbsp}

Nim, unlike many other languages, also supports https://en.wikipedia.org/wiki/Uniform_Function_Call_Syntax[Uniform Function Call Syntax], which allows many different ways of calling procedures.

This one is a call where the first argument is written before the function name, and the rest of the parameters are stated in parentheses:

[source]
----
<arg1>.<procName>(<arg2>, ...)
----

We have used this syntax when we were adding elements to an existing sequence (`<seq>.add(<element>)`), as this makes it more readable and expresses our intent more clearly than writing `add(<seq>, <element>)`.
We can also omit the parentheses around the arguments:

[source]
----
<procName> <arg1>, <arg2>, ...
----

We've seen this style being used when we call the `echo` procedure, and when calling the `len` procedure without any arguments.
These two can also be combined like this, but this syntax however is not seen very often:

[source]
----
<arg1>.<procName> <arg2>, <arg3>, ...
----


{nbsp}

The uniform call syntax allows for more readable chaining of multiple procedures:

[source]
.ufcs.nim
----
include::{source-dir}/ufcs.nim[]
----
<1> If multiple parameters are of the same type, we can declare their type in this compact way.
<2> First we add `a` and `b`, then the result of that operation (2 + 3 = 5) is passed as the first parameter to the `multi` procedure, where it is multiplied by `c` (5 * 4 = 20).
<3> First we multiply `c` and `b`, then the result of that operation (4 * 3 = 12) is passed as the first parameter to the `plus` procedure, where it is added with `a` (12 + 2 = 14).

[source, output]
----
true
true
20
14
----




== Result variable

In Nim, every procedure that returns a value has an implicitly declared and initialized (with a default value) `result` variable.
The procedure will return the value of this `result` variable when it reaches the end of its indented block, even with no `return` statement.

[source]
.result.nim
----
include::{source-dir}/result.nim[lines=1..9]
----
<1> The return type is `int`. The `result` variable is initialized with the default value for `int`: `0`.
<2> When the end of the procedure is reached, the value of `result` is returned.

[source, output]
----
33
----

Note that this procedure is here to demonstrate the `result` variable, and it is not 100% correct:
if you would pass a sequence containing only negative numbers, this procedure would return `0` (which is _not_ contained in the sequence).



{nbsp}


WARNING: Beware!
In older Nim versions (before Nim 0.19.0), the default value of strings and sequences was https://en.wikipedia.org/wiki/Null_pointer[`nil`], and when we would use them as returning types, the `result` variable would need to be initialized as an empty string (`""`) or as an empty sequence (`@[]`).

[source]
.result.nim
----
include::{source-dir}/result.nim[lines=11..20]
----
<1> In Nim version 0.19.0 and newer, this line is not needed -- sequences are automatically initialized as empty sequences. +
In older Nim versions, sequences must be initialized, and without this line the compiler would throw an error. (Notice that `var` must _not_ be used, as `result` is already implicitly declared.) 

[source, output]
----
@[1, 43, 57]
----


{nbsp}

Inside of a procedure we can also call other procedures.

[source]
.filterOdds.nim
----
include::{source-dir}/filterOdds.nim[]
----
<1> Once again, this line is not needed in the newer versions of Nim.
<2> Calling the previously declared procedure. Its return type is `bool` and can be used in the if-statement.
<3> The third way of calling a procedure, as we saw above.

[source, output]
----
@[6, 9, 0, 3]
@[3]
@[45390, 3219]
----





== Forward declaration

As mentioned in the very beginning of this section we can declare a procedure without a code block.
The reason for this is that we have to declare procedures before we can call them, doing this will not work:

[source]
----
echo 5.plus(10) # error      <1>

proc plus(x, y: int): int =  <2>
  return x + y
----
<1> This will throw an error as `plus` isn't defined yet.
<2> Here we define `plus`, but since it's after we use it Nim doesn't know about it yet.

The way to get around this is what's called a forward declaration:

[source]
----
proc plus(x, y: int): int    <1>

echo 5.plus(10)              <2>

proc plus(x, y: int): int =  <3>
  return x + y
----
<1> Here we tell Nim that it should consider the `plus` procedure to exist with this definition.
<2> Now we are free to use it in our code, this will work.
<3> This is were `plus` is actually implemented, this must of course match our previous definition.





== Exercises

1. Create a procedure which will greet a person (print "Hello <name>") based on the provided name. Create a sequence of names. Greet each person using the created procedure.

2. Create a procedure `findMax3` which will return the largest of three values.

3. Points in 2D plane can be represented as `tuple[x, y: float]`. Write a procedure which will receive two points and return a new point which is a sum of those two points (add x's and y's separately).

4. Create two procedures `tick` and `tock` which echo out the words "tick" and "tock". Have a global variable to keep track of how many times they have run, and run one from the other until the counter reaches 20. The expected output is to get lines with "tick" and "tock" alternating 20 times. (Hint: use forward declarations.)

NOTE: You can press Ctrl+C to stop execution of a program if you enter an infinite loop.

Test all procedures by calling them with different parameters.
