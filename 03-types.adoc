= 基本数据类型(Basic data types)



== 整数 Integers

如前一章所述，整数是没有小数部分且不带小数点的数字。

例如: `32` , `-174` , `0` , `10_000_000` 都是整数。注意，我们可以使用 ` _ ` 作为千位分隔符，使较大的数字更易读（比如写成 `10_000_000` 比 `10000000` 更容易看出我们指的是1000万）。

常见的数学运算符—-—加法（ `+` ）、减法（ `-` ）、乘法（ `*` ）和除法（ `/` ）—-—其行为与预期一致。前三种运算总是产生整数结果，而两个整数相除总会得到一个浮点数（带小数点的数），即使两数能够整除也不例外。


整数除法（丢弃小数部分的除法）可以通过 `div` 运算符实现。如果对整数除法的余数（模数）感兴趣，可以使用 `mod` 运算符。
这两个运算的结果始终是整数。

[source]
.integers.nim
----
include::{source-dir}/integers.nim[]
----
<1> `echo` 命令会将紧随其后由逗号分隔的所有内容打印到屏幕上。在本例中，它首先打印字符串 `a + b =` ，然后紧接着在同一行打印表达式 `a + b` 的结果。

我们可以编译并运行上述代码，输出结果应为:
[source, output]
----
a + b = 15
a - b = 7
a * b = 44
a / b = 2.75
a div b = 2
a mod b = 3
----




== 浮点数 Floats

浮点数，简称 floats，是实数的一种 https://en.wikipedia.org/wiki/Floating-point_arithmetic[近似表示] 。

For example: `2.73`, `-3.14`, `5.0`, `4e7` are floats.
Notice that we can use scientific notation for large floats, where the number after the `e` is the exponent.
In this example, `4e7` is a notation representing `4 * 10^7`.
例如： `2.73` , `-3.14` , `5.0` , `4e7` 是浮点数。注意，对于较大的浮点数，我们可以使用科学计数法，其中 e 后面的数字是指数。在这个例子中， `4e7` 是一种表示 `4*10^7` 的记法。


我们也可以在两个浮点数之间使用四种基本数学运算。运算符 div 和 mod 未针对浮点数定义。

[source]
.floats.nim
----
include::{source-dir}/floats.nim[]
----

[source, output]
----
c + d = 9.0  <1>
c - d = 4.5
c * d = 15.1875
c / d = 3.0  <1>
----
<1> 请注意，在加法和除法的例子中，即使我们得到的数字没有小数部分，结果仍然是浮点类型。

数学运算的优先级符合预期：乘法和除法的优先级高于加法和减法。

[source]
----
echo 2 + 3 * 4
echo 24 - 8 / 4
----

[source, output]
----
14
22.0
----




=== 浮点数和整数的转换


在Nim中，不同数值类型的变量之间无法进行数学运算，否则会产生错误：
[source]
----
let
  e = 5
  f = 23.456

echo e + f   # error
----

变量的值需要转换为同一类型。
转换过程很简单：要转换为整数，我们使用 `int` 函数；要转换为浮点数，则使用 `float` 函数。
[source]
----
let
  e = 5
  f = 23.987

echo float(e)      <1>
echo int(f)        <2>

echo float(e) + f  <3>
echo e + int(f)    <4>
----
<1> 打印一个整数的 `float` 形式。（ `e` 仍为整数类型）
<2> 打印浮点数`f`的 `int` 形式。
<3> 两个操作数均为浮点数，可以进行加法运算。
<4> 两个操作数都是整数，可以相加。


[source, output]
----
5.0
23
28.987
28
----

NOTE: 使用 `int` 函数将浮点数转换为整数时不会执行四舍五入操作，数字会直接舍弃小数部分。 +
要进行四舍五入运算，我们必须调用另一个函数，但在此之前需要先了解一些关于如何使用 Nim 的基础知识。




== 字符 Characters

`char` 类型用于表示单个 https://en.wikipedia.org/wiki/ASCII[ASCII] 字符。


字符写在两个单引号之间（ `'` ）。
字符可以是字母、符号或单个数字。
多个数字或多个字母会导致错误。
[source]
----
let
  h = 'z'
  i = '+'
  j = '2'
  k = '35' # error
  l = 'xy' # error
----




== 字符串 Strings

字符串可以被描述为一系列字符。
其内容写在两个双引号之间（ `"` ）。

我们可能认为字符串就是单词，但它们可以包含多个单词、一些符号(译者注：可以是utf-8字符)或数字。

[source]
.strings.nim
----
include::{source-dir}/strings.nim[]
----
<1> 一个空字符串
<2> 这不是数字（整数）。它在双引号内，因此是一个字符串。
<3> 尽管这只是一个字符，但它不是 char 类型，因为它被包含在双引号内。





=== 特殊字符 Special characters

如果我们尝试打印以下字符串：
[source]
----
echo "some\nim\tips"
----
结果可能会让我们感到惊讶：
[source, output]
----
some
im	ips
----

这是因为有几个字符具有特殊含义。
它们通过在字符前添加转义字符 `\` 来使用。

* `\n` 是换行符
* `\t` 是一个制表符
* `\\` 是一个反斜杠（因为一个 `\` 被用作转义字符）

如果我们想按照原样打印上面的示例，那么有两种可能选择：

* Use `\\` instead of `\` to print backslashes, or
* Use raw strings which have syntax `r"..."` (putting a letter `r` immediately before the first quote), in which there are no escape characters and no special meanings: everything is printed as it is.

[source]
----
echo "some\\nim\\tips"
echo r"some\nim\tips"
----

[source, output]
----
some\nim\tips
some\nim\tips
----

There are more special characters than the ones listed above, and they are all found in the https://nim-lang.org/docs/manual.html#lexical-analysis-string-literals[Nim manual].





=== String concatenation

Strings in Nim are mutable, meaning their content can change.
With the `add` function we can add (append) either another string or a char to an existing string.
If we don't want to change the original string, we can also concatenate (join together) strings with the `&` operator, this returns a new string.

[source]
.stringConcat.nim
----
include::{source-dir}/stringConcat.nim[]
----
<1> If we plan to modify strings, they should be declared as `var`.
<2> Adding another string modifies the existing string `p` in-place, changing its value.
<3> We can also add a `char` to a string.
<4> Concatenating two strings produces a new string, without modifying the original strings.

[source, output]
----
p is now: abcdef
q is now: xyz
concat: abcdefxyz
p is still: abcdef
q is still: xyz
----






== Boolean

A boolean (or just `bool`) data type can only have two values: `true` or `false`.
Booleans are usually used for control flow (see <<Control flow, next chapter>>), and they are often a result of relational operators.

The usual naming convention for boolean variables is to write them as a simple yes/no (true/false) question, e.g. `isEmpty`, `isFinished`, `isMoving`, etc.



=== Relational operators

Relational operators test the relation between two entities, which must be comparable.

To compare if two values are the same, `==` (two equal signs) is used.
Do not confuse this with `=`, which is used for assignment as we saw earlier.

Here are all the relational operators defined for integers:

[source]
.relationalOperators.nim
----
include::{source-dir}/relationalOperators.nim[lines=1..11]
----

[source, output]
----
g is greater than h: false
g is smaller than h: true
g is equal to h: false
g is not equal to h: true
g is greater or equal to h: false
g is smaller or equal to h: true
----


We can also compare characters and strings:

[source]
.relationalOperators.nim
----
include::{source-dir}/relationalOperators.nim[lines=13..30]
----
<1> All uppercase letters come before lowercase letters.
<2> String comparison works char-by-char. First three characters are the same, and character `b` is smaller than character `z`.
<3> String length doesn't matter for comparison if their characters are not identical.
<4> Shorter string is smaller than the longer one.

[source, output]
----
true
false
true
true
true
----




=== Logical operators

Logical operators are used to test the truthiness of an expression consisting of one or more boolean values.

* Logical `and` returns `true` only if both members are `true`
* Logical `or` returns `true` if there is at least one member which is `true`
* Logical `xor` returns `true` if one member is true, but the other is not
* Logical `not` negates the truthiness of its member: changing `true` to `false`, and vice versa (it is the only logical operator that takes just one operand)

[source]
.logicalOperators.nim
----
include::{source-dir}/logicalOperators.nim[]
----

[source, output]
----
T and T: true
T and F: false
F and F: false
---
T or T: true
T or F: true
F or F: false
---
T xor T: false
T xor F: true
F xor F: false
---
not T: false
not F: true
----


Relational and logical operators can be combined together to form more complex expressions.

For example: `(5 < 7) and (11 + 9 == 32 - 2*6)` will become `true and (20 == 20)`, which becomes `true and true`, and in the end this will give the final result of `true`.




== Recap

This was the longest chapter in this tutorial and we covered a lot of ground.
Take your time to go through each data type and experiment with what you can do with each of them.

Types might seem like a restriction at first, but they allow the Nim compiler to both make your code faster, and make sure you're not doing something wrong by accident -- this is especially beneficial in large code bases.

Now you know the basic data types and several operations on them, which should be enough to do some simple calculations in Nim.
Test your knowledge by doing the following exercises.




== Exercises

1. Create an immutable variable containing your age (in years). Print your age in days. (1 year = 365 days)
2. Check if your age is divisible by 3. (Hint: use `mod`)
3. Create an immutable variable containing your height in centimeters. Print your height in inches. (1 in = 2.54 cm)
4. A pipe has a 3/8 inch diameter. Express the diameter in centimeters.
5. Create an immutable variable containing your first name, and another one containing your last name. Make a variable `fullName` by concatenating the previous two variables. Don't forget to put a whitespace in-between. Print your full name.
6. Alice earns $400 every 15 days. Bob earns $3.14 per hour and works 8 hours a day, 7 days a week. After 30 days, has Alice earned more than Bob? (Hint: use relational operators)
